[{"/Users/jonggeun/Desktop/anfree/anfreeFront/anfree/src/index.js":"1","/Users/jonggeun/Desktop/anfree/anfreeFront/anfree/src/App.js":"2","/Users/jonggeun/Desktop/anfree/anfreeFront/anfree/src/reportWebVitals.js":"3","/Users/jonggeun/Desktop/anfree/anfreeFront/anfree/src/TodoList/ControllerTodoInput.js":"4","/Users/jonggeun/Desktop/anfree/anfreeFront/anfree/src/TodoList/RenderMemoInput.js":"5","/Users/jonggeun/Desktop/anfree/anfreeFront/anfree/src/TodoList/AppWelcome.js":"6","/Users/jonggeun/Desktop/anfree/anfreeFront/anfree/src/TodoList/AppClockCheckNow.js":"7","/Users/jonggeun/Desktop/anfree/anfreeFront/anfree/src/TodoList/AppTodolist.js":"8","/Users/jonggeun/Desktop/anfree/anfreeFront/anfree/src/TodoList/ControllerReadyTodoList.js":"9","/Users/jonggeun/Desktop/anfree/anfreeFront/anfree/src/TodoList/ControllerFilterTodoList.js":"10","/Users/jonggeun/Desktop/anfree/anfreeFront/anfree/src/TodoList/RenderTodoMemoDivReady.js":"11","/Users/jonggeun/Desktop/anfree/anfreeFront/anfree/src/TodoList/FunctionTodoMemo.js":"12","/Users/jonggeun/Desktop/anfree/anfreeFront/anfree/src/Modal.js":"13"},{"size":504,"mtime":1648454521278,"results":"14","hashOfConfig":"15"},{"size":2449,"mtime":1653033424382,"results":"16","hashOfConfig":"15"},{"size":362,"mtime":1648271251510,"results":"17","hashOfConfig":"15"},{"size":906,"mtime":1653029763737,"results":"18","hashOfConfig":"15"},{"size":719,"mtime":1653036006508,"results":"19","hashOfConfig":"15"},{"size":408,"mtime":1652079530744,"results":"20","hashOfConfig":"15"},{"size":299,"mtime":1652079510517,"results":"21","hashOfConfig":"15"},{"size":4584,"mtime":1653036369320,"results":"22","hashOfConfig":"15"},{"size":7760,"mtime":1653026407517,"results":"23","hashOfConfig":"15"},{"size":13111,"mtime":1652770161022,"results":"24","hashOfConfig":"15"},{"size":4816,"mtime":1653036370965,"results":"25","hashOfConfig":"15"},{"size":8838,"mtime":1653035274674,"results":"26","hashOfConfig":"15"},{"size":1073,"mtime":1653020819415,"results":"27","hashOfConfig":"15"},{"filePath":"28","messages":"29","suppressedMessages":"30","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"85wm2k",{"filePath":"31","messages":"32","suppressedMessages":"33","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"34","usedDeprecatedRules":"35"},{"filePath":"36","messages":"37","suppressedMessages":"38","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"39","messages":"40","suppressedMessages":"41","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"35"},{"filePath":"42","messages":"43","suppressedMessages":"44","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"45","usedDeprecatedRules":"35"},{"filePath":"46","messages":"47","suppressedMessages":"48","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"49","messages":"50","suppressedMessages":"51","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"52","messages":"53","suppressedMessages":"54","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"55","usedDeprecatedRules":"35"},{"filePath":"56","messages":"57","suppressedMessages":"58","errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"59","usedDeprecatedRules":"35"},{"filePath":"60","messages":"61","suppressedMessages":"62","errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"63","usedDeprecatedRules":"64"},{"filePath":"65","messages":"66","suppressedMessages":"67","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"68"},{"filePath":"69","messages":"70","suppressedMessages":"71","errorCount":0,"fatalErrorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"72","usedDeprecatedRules":"35"},{"filePath":"73","messages":"74","suppressedMessages":"75","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"76","usedDeprecatedRules":"35"},"/Users/jonggeun/Desktop/anfree/anfreeFront/anfree/src/index.js",[],[],"/Users/jonggeun/Desktop/anfree/anfreeFront/anfree/src/App.js",["77","78","79","80"],[],"import React, {useEffect, useState,useRef, useCallback} from 'react';\nimport './App.css';\nimport AppClockCheckNow from './TodoList/AppClockCheckNow.js';\nimport AppTodolist from './TodoList/AppTodolist.js'\nimport AppWelcome from './TodoList/AppWelcome.js'\nimport Modal from \"./Modal.js\"\n\nfunction History_nav(){\n  return(\n    <nav>\n        <div>LOGIN</div>\n        <div>CALENDER</div>\n        <div>STATICS</div>\n      </nav>\n  )\n}\n\n\nfunction App() {\n  const stageState = [\"EnterTodo\",\"FilterTodo\",\"EraseTodo\"];\n  const [prevStage,nextStage] = useState(0);\n  const [prevModalState, nextModalState] = useState(false);\n  \n  const setStageAppClassName = (prevStage)=>{\n    let nowStageClassName;\n    if(prevStage === 0){\n      nowStageClassName = 'App-EnterTodo';\n    }else if(prevStage === 1){\n      nowStageClassName = 'App-FilterTodo';\n    }else{\n      nowStageClassName = 'App-EraseTodo';\n    }\n    return nowStageClassName;\n  }\n\n\n  \n  /*\n  모달 로직 \n  모달을 통해서 confirm을 진행한다.\n  confirm됨과 동시에 이전단계로는 돌아 갈 수 없다.\n  FBI WARNING 띄워야찌~\n  */\n  const modalMessage = \"다음 단계로 넘어가면 이전 단계로는 돌아 갈 수 없습니다!\\n 정말로 넘아가시겠습니까?\"\n  \n\n  //Modal logic\n  const isInitialMount = useRef(false);\n  useEffect(() => {\n    if (!isInitialMount.current && prevStage !=2) {\n      isInitialMount.current = true;\n    }else{\n      return;\n    }\n  },[prevModalState]);\n\n\n\n  //modal close logic\n  const modelClose = () =>{\n    nextModalState(false)\n  }\n  const modelCloseAndGoNext = useCallback(() =>{\n    nextStage(prevStage+1);\n    nextModalState(false);\n  },[prevStage])\n\n  const modalOpen = ()=>{\n    nextModalState(true);\n  }\n\n\n  useEffect(()=>{\n    window.addEventListener(\"keydown\", (e) =>{\n      if(e.shiftKey && e.key=='Enter') {\n        modalOpen();\n      }\n    });\n  },)\n\n  return (\n    \n    <div className='App'>\n      <Modal\n      modalState={prevModalState}\n      header={stageState[prevStage]}\n      nowStage = {prevStage}\n      modelClose={modelClose}\n      modelCloseAndGoNext = {modelCloseAndGoNext}\n      >\n      {modalMessage}\n      </Modal>\n\n      <header className={setStageAppClassName(prevStage)}>\n        <History_nav/>\n        <AppWelcome/>\n        <AppClockCheckNow/>\n        <AppTodolist\n          stageState = {stageState}\n          nowStage = {prevStage}\n        />\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n",["81","82"],"/Users/jonggeun/Desktop/anfree/anfreeFront/anfree/src/reportWebVitals.js",[],[],"/Users/jonggeun/Desktop/anfree/anfreeFront/anfree/src/TodoList/ControllerTodoInput.js",[],[],"/Users/jonggeun/Desktop/anfree/anfreeFront/anfree/src/TodoList/RenderMemoInput.js",["83"],[],"import React from \"react\";\n\nfunction RenderMemoInput({renderTodoList,listSelector,todoSelector,memoSelector,memoUpdate}){\n    return(\n        <input\n        className=\"todoMemoInput-memo\"\n        type = 'text'\n            placeholder=\"add Memo!\"\n            onKeyPress={function(e){\n                if(e.nativeEvent.key === 'Enter'){\n                    e.preventDefault();\n                    var resetMemo = Array.from(renderTodoList);\n                    resetMemo[listSelector][todoSelector].memolist.push(e.target.value);\n                    memoUpdate(resetMemo);\n                    e.target.value=\"\"\n                }\n            }.bind(this)}\n        >\n        </input>\n    );\n};\nexport default RenderMemoInput","/Users/jonggeun/Desktop/anfree/anfreeFront/anfree/src/TodoList/AppWelcome.js",[],[],"/Users/jonggeun/Desktop/anfree/anfreeFront/anfree/src/TodoList/AppClockCheckNow.js",[],[],"/Users/jonggeun/Desktop/anfree/anfreeFront/anfree/src/TodoList/AppTodolist.js",["84","85","86"],[],"import React, {useEffect, useState, useRef, useCallback} from \"react\";\nimport RenderTodoMemoDivReady from \"./RenderTodoMemoDivReady\"\n// import ControllerReadyTodoList from \"./ControllerReadyTodoList.js\"\nimport ControllerTodoInput from \"./ControllerTodoInput.js\";\n// import ControllerFilterTodoList from \"./ControllerFilterTodoList.js\"\nimport * as funcActionTM from \"./FunctionTodoMemo.js\"\n\n// import Modal from \"./Modal.js\";\n\n\n\n\n\nexport default function AppTodolist(props) {\n  const {stageState,nowStage} = props;\n  const [prevTodoList, changeTodoList] = useState([[],[],[]]);\n  const [listSelector, changeListSelector] = useState(1);\n  const [memoSelector, changeMemoSelector] = useState(-1);\n  const [todoSelector, changeTodoSelector] = useState(-1);\n  //todoMode \n  // true -> todo\n  // false -> memo\n  const [todoMode, changeTodoMode] = useState(true);\n  const ActionTodoMemo =useCallback((calListSelector,calTodoSelector,calList)=>{\n    changeTodoList(calList);\n    changeListSelector(calListSelector);\n    changeTodoSelector(calTodoSelector);\n  })\n  \n  const updateListFromInput=(updateTodoList) =>{\n    changeTodoList(updateTodoList)\n  }\n\n\n  const keyDownEvent =(e)=>{\n    let swapSet, moveSet,deleteSet;\n    let swapMemoSet, moveMemoSet, deleteMemoSet;\n\n      if(e.shiftKey && 37<=e.keyCode && e.keyCode<=40){\n        if(todoMode){\n          swapSet = funcActionTM.swapTodoContents(todoSelector,listSelector, e, nowStage, prevTodoList);\n          if(swapSet !=null) return ActionTodoMemo(swapSet[0],swapSet[1],swapSet[2]);\n        }else{\n          swapMemoSet = funcActionTM.swapMemoContents(e,listSelector,todoSelector,memoSelector,prevTodoList)\n          if(swapMemoSet !=null) return ActionTodoMemo(swapMemoSet[0],swapMemoSet[1],swapMemoSet[2]);\n        }\n      }\n      //move\n      else if(37<=e.keyCode && e.keyCode<=40){\n        if(todoMode){\n          moveSet = funcActionTM.moveTodoContents(todoSelector,listSelector, e, nowStage, prevTodoList)\n          if(moveSet !=null) return ActionTodoMemo(moveSet[0],moveSet[1],moveSet[2]);  \n        }else{\n          moveMemoSet = funcActionTM.moveMemoContents(e, listSelector, todoSelector,memoSelector,prevTodoList)\n          if(moveMemoSet!=null) changeMemoSelector(moveMemoSet);\n        }\n      }\n      //Enter memo mode\n      else if(e.key ==='/'){\n        changeTodoMode(!todoMode);\n      }\n      //delete\n      else if(e.shiftKey && e.key === 'Delete'){\n        if(todoMode){\n          deleteSet = funcActionTM.deleteTodoContents(listSelector,todoSelector,prevTodoList);\n          if(deleteSet !=null)return ActionTodoMemo(deleteSet[0],deleteSet[1],deleteSet[2]);  \n        }else{\n          deleteMemoSet = funcActionTM.deleteMemoContents(listSelector,todoSelector,memoSelector,prevTodoList);\n          if(deleteMemoSet!=null) return ActionTodoMemo(deleteMemoSet[0],deleteMemoSet[1],deleteMemoSet[2])\n        }\n      }\n\n  }\n\n\n  useEffect(()=>{\n    window.addEventListener(\"keydown\",keyDownEvent);\n    return() =>{\n      window.removeEventListener(\"keydown\",keyDownEvent);\n    }\n  })\n\n\n\n  console.log(todoMode)\n  return(\n    //조건부 렌더링\n    <div>\n      {\n      (nowStage === 0) ? (\n        <div>\n        <ControllerTodoInput \n        nowTodoList = {prevTodoList} \n        updateContents={updateListFromInput}\n        ></ControllerTodoInput>\n        \n        <RenderTodoMemoDivReady\n          listSelector = {listSelector}\n          todoSelector = {todoSelector}\n          renderTodoList = {prevTodoList}\n          memoSelector = {memoSelector}\n          todoMode = {todoMode}\n          memoUpdate = {updateListFromInput}\n        ></RenderTodoMemoDivReady>\n        </div>\n      ) : null}\n\n\n      \n    </div>\n\n\n    // <div>\n    //   {props.nowStage === 0 ? (\n    //     <ControllerTodoInput \n    //     _stage = {props.nowStage}\n    //     _contents = {prevTodoList} \n    //     updateContents={nextTodoList}></ControllerTodoInput>\n    //   ):null}\n    //   {\n    //     (props.nowStage === 0) ? (\n    //       <ControllerReadyTodoList \n    //         _contents={prevTodoList}\n    //         _stage = {props.nowStage}\n    //         updateContentsTodoList={nextTodoList}\n    //       ></ControllerReadyTodoList>\n    //     ) : (\n    //       (props.nowStage === 1) ? (\n    //         <ControllerFilterTodoList \n    //           _contents={prevTodoList}\n    //           _stage = {props.nowStage}\n    //           updateContentsTodoList={nextTodoList}\n    //       ></ControllerFilterTodoList>\n    //       ) : (\n    //         console.log(\"hi\")\n    //       )\n    //     )\n\n\n    //   }\n    // </div>\n    \n  );\n\n}\n","/Users/jonggeun/Desktop/anfree/anfreeFront/anfree/src/TodoList/ControllerReadyTodoList.js",["87","88","89","90","91","92","93"],[],"import { render } from \"@testing-library/react\";\nimport React, {Component, memo} from \"react\";\nimport RenderTodoMemoDivReady from \"./RenderTodoMemoDivReady\";\nimport * as moveLogic from \"./FunctionTodoMemo.js\"\n\n// mode, contents\nclass RenderTodoList extends Component{\n    constructor(props){\n        super(props);\n        //actionMode : writeMode, selectorMode,\n        this.actionMode = 'writeMode';\n        // writeContentMode : todoList, memoList\n        this.writeContentMode = 'todoList';\n        // TodoList controll selector\n        this.currentTodoSelector = -1;\n        this.currentMemoSelector = -1;\n        this.currentListIndex = 1;\n        // filterTodo cursor\n        this.state={\n            pressArrowDirection : ''\n        }\n    }\n    \n    componentDidMount() {\n        window.addEventListener('keydown',(e)=>{\n            if(e.shiftKey && 37<=e.keyCode && e.keyCode<=40 && this.actionMode === 'selectorMode'){\n                var _pressArrowDirection = e.key;\n\n                if(this.actionMode==='selectorMode' && this.writeContentMode==='memoList'){\n                    let memolength = this.props._contents[1][this.currentTodoSelector].memolist.length;\n                    if(_pressArrowDirection === 'ArrowDown' && this.currentMemoSelector!=memolength-1){\n                        this.props.updateContentsTodoList(moveLogic.swapMemoContents('down',1,this.currentTodoSelector,this.currentMemoSelector,this.props._contents));\n                    }else if(_pressArrowDirection==='ArrowUp' && this.currentMemoSelector !=0){\n                        this.props.updateContentsTodoList(moveLogic.swapMemoContents('up',1,this.currentTodoSelector,this.currentMemoSelector,this.props._contents));\n                    }\n                }else{\n                    if(_pressArrowDirection === 'ArrowDown' && this.currentTodoSelector!=this.props._contents[1].length-1){\n                        this.props.updateContentsTodoList(moveLogic.swapTodoContents('down',1,this.currentTodoSelector,this.props._contents));\n                    }else if(_pressArrowDirection==='ArrowUp' && this.currentTodoSelector !=0){\n                        this.props.updateContentsTodoList(moveLogic.swapTodoContents('up',1,this.currentTodoSelector,this.props._contents));\n                    }\n                }\n            }\n\n            /**\n             * 메모기능 구현\n             * selector Mode 일 때 '/'를 누르면 메모 모드로 들어가기\n             * input창이 떠야하고 -> 입력하면 this.props._contents가 업데이트 되어야 함\n             * _contents의 자료구조는 list 이어야 하는가? component이어야 하는가?\n             * 아니면 javascript 구조로 class를 만들어야 하는가? 고민이네\n             * ----> class로 만들어서 memo랑 같이 관리하자 ㅇㅇ 이게 답인듯\n             */\n            if(this.actionMode === 'selectorMode' && e.key === '/'){\n                if(this.writeContentMode === 'todoList') this.writeContentMode = 'memoList';\n                else {\n                    this.writeContentMode = 'todoList';\n                    this.currentMemoSelector = -1;\n                }\n                e.target.value = \"\";\n                this.forceUpdate();\n            }\n\n            /*\n                delete 기능 구현\n            */\n            if(e.shiftKey && e.key === 'Delete'){\n                var _deleteContents = Array.from(this.props._contents)\n                if(this.actionMode==='selectorMode' && this.writeContentMode==='memoList'){\n                    if(_deleteContents[1][this.currentTodoSelector].memolist.lengt!==0){\n                        _deleteContents = moveLogic.deleteMemoContents(1,this.currentTodoSelector,this.currentMemoSelector,_deleteContents);\n                        if(this.currentMemoSelector=== _deleteContents[1][this.currentTodoSelector].memolist.lengt-1){\n                            this.currentMemoSelector = this.currentMemoSelector-1;\n                        }\n                    }\n                }else{\n                    if(_deleteContents.length ===1){\n                        _deleteContents[1] = []\n                        this.currentTodoSelector = this.currentTodoSelector-1;\n                        this.mode = 'writeMode'\n                    }\n                    else if(_deleteContents.length !==0){\n                        _deleteContents = moveLogic.deleteTodoContents(1,this.currentTodoSelector,_deleteContents);\n                        console.log(_deleteContents);\n                        if(this.currentTodoSelector === _deleteContents[1].length-1){\n                            this.currentTodoSelector = this.currentTodoSelector-1;\n                        }\n                    }\n                }\n                this.props.updateContentsTodoList(_deleteContents);\n            }\n            /*\n                writeMode vs selectorMode \n                위아래로 커서 변경하는 상황\n                ************************* need refactorying **********************\n            */\n            if(37<=e.keyCode && e.keyCode<=40){\n                var _pressArrowDirection = e.key;\n                \n                if(this.actionMode==='selectorMode' && this.writeContentMode==='memoList'){\n                    //controll memo mode\n                    let nowMemolist = this.props._contents[1][this.currentTodoSelector].memolist;\n                    if(_pressArrowDirection === 'ArrowDown'){\n                        \n                        if(nowMemolist.length !== 0){\n                            this.currentMemoSelector = (nowMemolist.length-1 === this.currentMemoSelector) ? nowMemolist.length-1: this.currentMemoSelector+1;    \n                        }\n                    }else if(_pressArrowDirection === 'ArrowUp'){\n                        if(nowMemolist.length!==0){\n                            this.currentMemoSelector = (this.currentMemoSelector === 0)? 0 : this.currentMemoSelector-1;\n                        }\n                    }\n                }else{\n                    //controll todo mode\n                    if(_pressArrowDirection === 'ArrowDown'){\n                        if(this.actionMode==='writeMode' && this.props._contents[1].length!==0){\n                            this.currentTodoSelector = 0;\n                            this.actionMode = 'selectorMode'\n                        }else if(this.actionMode === 'selectorMode'){\n                            this.currentTodoSelector = (this.currentTodoSelector === this.props._contents[1].length-1)? this.props._contents[1].length-1 : this.currentTodoSelector+1;                        \n                        }\n                    }else if(_pressArrowDirection === 'ArrowUp'){\n                        if(this.actionMode === 'selectorMode'){\n                            if(this.currentTodoSelector === 0){\n                                this.actionMode ='writeMode'\n                            }else{\n                                this.currentTodoSelector = (this.currentTodoSelector === 0)? 0 : this.currentTodoSelector-1;\n                            }\n                        }\n                    }\n                }\n                this.forceUpdate();\n            }//end arrow if test\n        })\n    }\n\n\n    render(){\n        return(\n            <div className='EnterTodo'>\n                <RenderTodoMemoDivReady\n                _contents={this.props._contents[1]}\n                _mode = {this.actionMode}\n                _currentTodoSelector = {this.currentTodoSelector}\n                _currentMemoSelector = {this.currentMemoSelector}\n                _writeContentMode = {this.writeContentMode}\n                ></RenderTodoMemoDivReady>\n            </div>\n        )\n    }\n}\n\nexport default RenderTodoList;","/Users/jonggeun/Desktop/anfree/anfreeFront/anfree/src/TodoList/ControllerFilterTodoList.js",["94","95","96","97","98","99","100","101"],[],"import { render } from \"@testing-library/react\";\nimport React, {Component, memo} from \"react\";\nimport RenderTodoMemoDiveFilter from \"./RenderTodoMemoDiveFilter\";\n\n// mode, contents\nclass RenderTodoList extends Component{\n    constructor(props){\n        super(props);\n        //actionMode : writeMode, selectorMode,\n        this.actionMode = 'selectorMode';\n        this.currentTodoSelector = 0;\n        this.currentMemoSelector = -1;\n        this.writeContentMode = 'todoList'\n        // filterTodo cursor\n        this.filterTodoCursorListCnt =1;     \n        this.state={\n            pressArrowDirection : ''\n        }\n    }\n    /*\n    TodoList 위아리 바꾸기\n    UpDown : 위인지 아래인지\n    targetList : 지우고자 하는 list => 0,1,2\n    currentTodoSelector : 현재 선택된 번호 => 몇번째가 선택 되었는지\n    updateFunction : 함수에서 callback 하는 구조 => property에서 받아온 값\n    propsContents : property로 부터 받아온 [[],[],[]] 리스트 전체\n    */\n    swapTodoContents(UpDown,targetList,currentSelector,updateFunction,propsContents){\n        var upDownInt = (UpDown === 'up')? -1 :1;\n        var updateContentsList = Array.from(propsContents);\n        var temp = updateContentsList[targetList][currentSelector];\n        updateContentsList[targetList][currentSelector] = updateContentsList[targetList][currentSelector+upDownInt];\n        updateContentsList[targetList][currentSelector+upDownInt] = temp;\n        updateFunction(updateContentsList);\n    }\n\n    /*\n    Memo 위아래 바꾸기\n    UpDown : 위인지 아래인지\n    targetList : 지우고자 하는 list => 0,1,2\n    currentTodoSelector : 현재 선택된 번호 => 몇번째가 선택 되었는지\n    currentMemoSelector : 현재 선택된 메모 번호\n    updateFunction : 함수에서 callback 하는 구조 => property에서 받아온 값\n    propsContents : property로 부터 받아온 [[],[],[]] 리스트 전체\n    */\n    swapMemoContents(UpDown,targetList,currentTodoSelector,currentMemoSelector,updateFunction,propsContents){\n        let memoIdx = currentMemoSelector;\n        let todoIdx = currentTodoSelector;\n        var upDownInt = (UpDown === 'up')? -1 :1;\n        var updateContentsList = Array.from(propsContents);\n        var temp = updateContentsList[targetList][todoIdx].memolist[memoIdx];\n        updateContentsList[targetList][todoIdx].memolist[memoIdx] = updateContentsList[targetList][todoIdx].memolist[memoIdx + upDownInt];\n        updateContentsList[targetList][todoIdx].memolist[memoIdx+upDownInt] = temp;\n        updateFunction(updateContentsList);\n    }\n\n    /*\n    MemoList 삭제\n    targetList : 지우고자 하는 list => 0,1,2\n    currentTodoSelector : 현재 선택된 번호 => 몇번째가 선택 되었는지\n    currentMemoSelector : 현재 선택된 메모 번호\n    propsContents : property로 부터 받아온 [[],[],[]] 리스트 전체\n    */\n    deleteMemoContents(targetList,currentTodoSelector,currentMemoSelector,propsContents){\n        let memolength = propsContents[targetList][currentTodoSelector].memolist.length;\n        for(var i = currentMemoSelector; i<propsContents[targetList][currentTodoSelector].length-1; i++){\n            propsContents[targetList][currentTodoSelector].memolist[i] = \n            propsContents[targetList][currentTodoSelector].memolist[i+1]\n        }\n        propsContents[targetList][currentTodoSelector].memolist=\n        propsContents[targetList][currentTodoSelector].memolist.slice(0,memolength-1);\n        return propsContents;\n    }\n\n    // 함수에는 해당되는 기능만을 집중해서 구현하자 -> 함수는 필요한 것만!\n    /*\n    TodoList 삭제\n    targetList : 지우고자 하는 list => 0,1,2\n    currentTodoSelector : 현재 선택된 번호 => 몇번째가 선택 되었는지\n    propsContents : property로 부터 받아온 [[],[],[]] 리스트 전체\n    */\n    deleteTodoContents(targetList,currentTodoSelector,propsContents){\n        for(var i=currentTodoSelector; i<propsContents[targetList].length-1; i++){\n            propsContents[targetList][i] = propsContents[targetList][i+1];\n        }\n        propsContents = propsContents[targetList].slice(0,propsContents.length-1);\n        return propsContents;\n    }\n\n\n    /*\n    nowListNum : 현재 cursor number\n    LeftRight : 이동해야하는 방향\n    */\n    changeFilterListCnt(nowListNum, LeftRight, propsContents){\n        if(LeftRight === 'ArrowRight'){\n            if(nowListNum === 1) {\n                if(propsContents[2].length ===0) nowListNum =1;\n                else nowListNum = 2;\n            }\n            else if(nowListNum === 0){\n                if(propsContents[1].length !==0) nowListNum = 1;\n                else if(propsContents[1].length ===0 && propsContents[2].length!==0) nowListNum = 2;\n                else nowListNum =0;\n            }\n        }\n        else if(LeftRight === 'ArrowLeft'){\n            if(nowListNum === 1) {\n                if(propsContents[0].length ===0) nowListNum =1;\n                else nowListNum =0;\n            }\n            else if(nowListNum ===2){\n                if(propsContents[1].length!==0) nowListNum =1;\n                else if(propsContents[1].length === 0 && propsContents[0].length!==0) nowListNum =0;\n                else nowListNum = 2;\n            }\n        }\n        return nowListNum;\n    }\n\n    changeFilterListElement(nowListNum, LeftRight, nowListIdx , propsContents, updateFunction){\n        \n        let changeFilterList = Array.from(propsContents);\n        let moveIdx =-1;\n        // 상태 변경\n        if(moveIdx === -1){\n            if(LeftRight === 'ArrowRight' && nowListNum === 2 ) return;\n            else if(LeftRight === 'ArrowRight' && nowListNum !=2 ) moveIdx = nowListNum+1;\n            else if(LeftRight === 'ArrowLeft' && nowListNum === 0 ) return;\n            else if(LeftRight === 'ArrowLeft' && nowListNum !== 0  )moveIdx = nowListNum-1;\n        }\n\n        let changeMode =(moveIdx === 0 )? 'willNotDo' : ((moveIdx === 1) ? 'ready' : 'willDo');\n        changeFilterList[nowListNum][nowListIdx].todoState = changeMode;\n        // 이동시킴\n        changeFilterList[moveIdx].push(changeFilterList[nowListNum][nowListIdx]);\n        // 원래 list에서 제거\n        for(let i=nowListIdx; i<changeFilterList[nowListNum].length-1; i++){\n            changeFilterList[nowListNum][i] = changeFilterList[nowListNum][i+1];\n        }\n        changeFilterList[nowListNum] = changeFilterList[nowListNum].slice(0, changeFilterList[nowListNum].length-1);\n        return updateFunction(changeFilterList);\n    }\n\n    componentDidMount() {\n        window.addEventListener('keydown',(e)=>{\n            // console.log(\"controllerfiltertodolist \",this.props._contents);\n            if(this.props._stage === 1){\n                console.log(\"controllerFilterTodoList : componentDidMount start\", this.props._stage);\n                // 위치변경 로직\n                if(e.shiftKey && 37<=e.keyCode && e.keyCode<=40 && this.actionMode === 'selectorMode'){\n                    var _pressArrowDirection = e.key;\n                    // console.log(this.props._contents);\n                    if(this.actionMode==='selectorMode' && this.writeContentMode==='memoList'){\n                        let memolength = this.props._contents[this.filterTodoCursorListCnt][this.currentTodoSelector].memolist.length;\n                        if(_pressArrowDirection === 'ArrowDown' && this.currentMemoSelector!=memolength-1){\n                            this.swapMemoContents('down',this.filterTodoCursorListCnt,this.currentTodoSelector,this.currentMemoSelector,this.props.updateContentsTodoList,this.props._contents);\n                        }else if(_pressArrowDirection==='ArrowUp' && this.currentMemoSelector !=0){\n                            this.swapMemoContents('up',this.filterTodoCursorListCnt,this.currentTodoSelector,this.currentMemoSelector,this.props.updateContentsTodoList,this.props._contents);\n                        }\n                    }else{\n                        if(_pressArrowDirection === 'ArrowDown' && this.currentTodoSelector!=this.props._contents[this.filterTodoCursorListCnt].length-1){\n                            this.swapTodoContents('down',this.filterTodoCursorListCnt,this.currentTodoSelector,this.props.updateContentsTodoList,this.props._contents);\n                        }else if(_pressArrowDirection==='ArrowUp' && this.currentTodoSelector !=0){\n                            this.swapTodoContents('up',this.filterTodoCursorListCnt,this.currentTodoSelector,this.props.updateContentsTodoList,this.props._contents);\n                        }\n                    }\n\n                    // change todoList mode\n                    // todoList mode를 바꾼다. Not will Do and Will Do\n                    if(_pressArrowDirection === 'ArrowLeft'){\n                        this.changeFilterListElement(this.filterTodoCursorListCnt, 'ArrowLeft', this.currentTodoSelector , this.props._contents, this.props.updateContentsTodoList);\n                    }else if(_pressArrowDirection === 'ArrowRight'){\n                        this.changeFilterListElement(this.filterTodoCursorListCnt, 'ArrowRight', this.currentTodoSelector , this.props._contents, this.props.updateContentsTodoList);\n                    }\n\n                    \n                    // this.forceUpdate();\n                }\n\n\n\n                // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n                // filterTodo 상태에서 이동제어\n                // 이동에 관한 것\n                // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n                else if(37<=e.keyCode && e.keyCode<=40){\n                    var _pressArrowDirection = e.key;\n                    if(this.actionMode==='selectorMode' && this.writeContentMode==='memoList'){\n                        //controll memo mode\n                        let nowMemolist = this.props._contents[this.currentTodoSelector].memolist;\n                        if(_pressArrowDirection === 'ArrowDown'){\n                            if(nowMemolist.length !== 0){\n                                this.currentMemoSelector = (nowMemolist.length-1 === this.currentMemoSelector) ? nowMemolist.length-1: this.currentMemoSelector+1;    \n                            }\n                        }else if(_pressArrowDirection === 'ArrowUp'){\n                            if(nowMemolist.length!==0){\n                                this.currentMemoSelector = (this.currentMemoSelector === 0)? 0 : this.currentMemoSelector-1;\n                            }\n                        }\n                    }else{\n                        //controll todo mode\n                        if(_pressArrowDirection === 'ArrowDown'){\n                            this.currentTodoSelector = (this.currentTodoSelector === this.props._contents[this.filterTodoCursorListCnt].length-1)? this.props._contents[this.filterTodoCursorListCnt].length-1 : this.currentTodoSelector+1;                        \n                        }else if(_pressArrowDirection === 'ArrowUp'){\n                            this.currentTodoSelector = (this.currentTodoSelector === 0)? 0 : this.currentTodoSelector-1;\n                        }else if(_pressArrowDirection === 'ArrowLeft'){\n                            this.filterTodoCursorListCnt = this.changeFilterListCnt(this.filterTodoCursorListCnt, \"ArrowLeft\",this.props._contents);\n                            this.currentTodoSelector =0;\n                        }else if(_pressArrowDirection === 'ArrowRight'){\n                            this.filterTodoCursorListCnt = this.changeFilterListCnt(this.filterTodoCursorListCnt, \"ArrowRight\",this.props._contents);\n                            this.currentTodoSelector =0;\n                        }\n                    }\n                    this.forceUpdate();\n                }\n\n\n                // 메모의 상태를 변경하기 위해서 사용\n                if(this.actionMode === 'selectorMode' && e.key === '/'){\n                    if(this.writeContentMode === 'todoList') {\n                        this.writeContentMode = 'memoList';\n                        this.currentMemoSelector = 0;\n                    }\n                    else {\n                        this.writeContentMode = 'todoList';\n                        this.currentMemoSelector = -1;\n                    }\n                    e.target.value = \"\";\n                    this.forceUpdate();\n                }\n                \n            }\n            \n            \n        })\n    }\n\n\n\n    render(){\n        // console.log(\"render time \" ,this.props._contents);\n        return(\n            <div className=\"FilterTodo\">\n            <RenderTodoMemoDiveFilter\n                _currentTodoSelector = {this.currentTodoSelector}\n                _currentMemoSelector = {this.currentMemoSelector}\n                _filterTodoCursorListCnt = {this.filterTodoCursorListCnt}\n                _filterTodoCursorList = {this.props._contents}\n            ></RenderTodoMemoDiveFilter>\n            </div>\n        )\n    }\n}\n\nexport default RenderTodoList;",["102","103"],"/Users/jonggeun/Desktop/anfree/anfreeFront/anfree/src/TodoList/RenderTodoMemoDivReady.js",["104","105","106","107"],[],"import React ,{ memo, useState}from \"react\";\nimport RenderMemoInput from \"./RenderMemoInput\";\nimport \"./RenderTodoElementEnter.css\"\n\nfunction TodoMemoDivReady(props){\n    const {listSelector,todoSelector,renderTodoList,memoSelector,todoMode,memoUpdate} = props;\n    console.log(props)\n    var returnRenderList =[]\n    const makeMemoDivList =(memoListByList,memoSelector)=>{\n        return(\n            memoListByList.map((memoElement,index)=>(\n                <div className={(memoSelector===index ) ? \"memoElement-now\":\"memoElement\"} key={index+ \"_\"+ memoElement}>{memoElement}</div>\n            ))\n        )\n    }\n\n    const makeReadyTodoDivList = (listSelector,todoSelector,renderTodoList,memoSelector) =>{\n        let tempArr = []; \n        let i=0;\n        let setClassName = \"READY\";\n        while(i<renderTodoList[listSelector].length){            \n            if(!todoMode&& i === todoSelector){\n                tempArr.push(\n                    <div className={(todoSelector === i)? setClassName + \"-now\" : setClassName} key={renderTodoList[i] + \"-\" + i}>\n                        {renderTodoList[listSelector][i].todolist}\n                        <div className=\"MemoInput\" key={renderTodoList[i].todolist +\"mempInputs\"}>\n                        <RenderMemoInput\n                            renderTodoList = {renderTodoList}\n                            memoSelector = {memoSelector}\n                            listSelector = {listSelector}\n                            todoSelector = {todoSelector}\n                            memoUpdate = {memoUpdate}\n                        />\n                        </div>\n                        {(renderTodoList[listSelector][i].memolist.length !=0)? makeMemoDivList(renderTodoList[listSelector][i].memolist,memoSelector) : null}\n                    </div>\n                )\n            }\n            else{\n                tempArr.push(\n                    <div className={(todoSelector === i)? setClassName + \"-now\" : setClassName} key={renderTodoList[i] + \"-\" + i}>\n                        {renderTodoList[listSelector][i].todolist}\n                        {(renderTodoList[listSelector][i].memolist.length !=0)? makeMemoDivList(renderTodoList[listSelector][i].memolist,memoSelector) : null}\n                    </div>\n                )\n            }\n            i = i+1;\n        }\n        return tempArr;\n    }\n    \n    returnRenderList.push(makeReadyTodoDivList(listSelector,todoSelector,renderTodoList,memoSelector));\n\n\n    // var renderContainer = Array.from(renderTodoList);\n    // var i=0;\n    \n    // if(ActionMode === 'selectorMode'){\n    //     while(i<renderContainer.length){\n    //         if(todoSelector!==-1 && i===todoSelector){\n    //             if(writeMode ==='memoList'){\n    //                 returnList.push(\n    //                     <div className=\"todoMainElement-now\" key={renderContainer[i].todolist}>\n    //                         {renderContainer[i].todolist}\n    //                         <div className=\"MemoInput\" key={renderContainer[i].todolist +\"mempInputs\"}>\n    //                             <RenderMemoInput\n    //                                 _memoContents = {renderContainer}\n    //                                 _memoIdx = {todoSelector}\n    //                                 _setterContents = {setAfterContents}\n    //                             ></RenderMemoInput> \n    //                         </div>\n    //                         {makeMemoDivList(renderContainer[i].memolist,memoSelector)}\n    //                     </div>\n    //                 );\n    //             }else{\n    //                 returnList.push(\n    //                     <div className=\"todoMainElement-now\" key={renderContainer[i].todolist}>\n    //                         {renderContainer[i].todolist}\n    //                         {makeMemoDivList(renderContainer[i].memolist,-1)}\n    //                     </div>\n    //                 );\n    //             }\n    //         }else{\n    //             returnList.push(\n    //                 <div className=\"todoMainElement\" key={renderContainer[i].todolist}>\n    //                     {renderContainer[i].todolist}\n    //                     {makeMemoDivList(renderContainer[i].memolist,-1)}\n    //                 </div>\n    //             );\n    //         }\n    //         i=i+1;\n    //     }//end while\n    // }else{\n    //     while(i<renderContainer.length){\n    //         returnList.push(\n    //         <div className=\"todoMainElement\" key={renderContainer[i].todolist}>\n    //             {renderContainer[i].todolist}\n    //             {makeMemoDivList(renderContainer[i].memolist,-1)}\n    //         </div>\n    //         );\n            \n    //         i=i+1\n    //     }\n    // }\n    return(\n        returnRenderList\n    );\n};\n\nexport default TodoMemoDivReady; ","/Users/jonggeun/Desktop/anfree/anfreeFront/anfree/src/TodoList/FunctionTodoMemo.js",["108","109","110","111","112","113","114","115","116","117","118","119","120","121","122"],[],"    \n\n    //swap, delete은 list를 같이 반환\n    //그냥 move는 todoSelector와 listSelector를 반환\n    export const swapUpAndDown =(todoSelector,listSelector,pressedKey,todoList)=>{\n        let swapTodoList = Array.from(todoList);\n        let NextTodoSelector = (pressedKey.key ==='ArrowUp')? todoSelector-1: todoSelector +1;\n        //넘어가는지 확인 해줘야 한다.\n        if(NextTodoSelector <0 || NextTodoSelector >todoList[listSelector].length-1){\n            return null;\n        } \n        let temp = swapTodoList[listSelector][todoSelector] = swapTodoList[listSelector][todoSelector];\n        swapTodoList[listSelector][todoSelector] = swapTodoList[listSelector][NextTodoSelector];\n        swapTodoList[listSelector][NextTodoSelector] = temp;\n        return [listSelector,NextTodoSelector, swapTodoList];\n    }\n\n    //state변경까지해야한다.\n    //check는 큰 function에서 진행\n    export const swapRightAndLeft = (todoSelector,listSelector,pressedKey,todoList)=>{\n        let swapTodoList = Array.from(todoList);\n        let nextTodoSelector = 0 ; let nextListSelctor;\n        if(pressedKey.key === 'ArrowRight'){\n            nextListSelctor = (listSelector !=2)? nextListSelctor+1 : nextListSelctor;\n        }else if(pressedKey.key === 'ArrowLeft'){\n            nextListSelctor = (listSelector !=0)? nextListSelctor-1 : nextListSelctor;\n        } \n        //상태 재설정\n        swapTodoList[listSelector][todoSelector].todoState = (nextListSelctor === 0) ? 'WILLNOTDO': (nextListSelctor ===1) ? 'READY' : \"WILLDO\";\n        //타겟 todo에 추가\n        swapTodoList[nextListSelctor].push(swapTodoList[listSelector][todoSelector]);\n        //원본 제거\n        deleteTodoContents(listSelector,todoSelector,swapTodoList);\n        //변경된 위치의 todoSelector 재설정\n        nextTodoSelector = swapTodoList[nextListSelctor].length-1;\n        return [nextListSelctor,nextTodoSelector,swapTodoList];   \n    }\n    /*\n    TodoList 위아리 바꾸기\n    UpDonw : 위인지 아래인지\n    targetList : 지우고자 하는 list => 0,1,2\n    currentTodoSelector : 현재 선택된 번호 => 몇번째가 선택 되었는지\n    updateFunction : 함수에서 callback 하는 구조 => property에서 받아온 값\n    propsContents : property로 부터 받아온 [[],[],[]] 리스트 전체\n    */\n    export const swapTodoContents =(todoSelector,listSelector, pressedKey, nowStage, todoList)=>{\n        if(nowStage ===0){\n            if(pressedKey.key === 'ArrowUp' || pressedKey.key ==='ArrowDown'){\n                return swapUpAndDown(todoSelector,listSelector,pressedKey,todoList);\n            }\n            return null;\n        }\n        else if(nowStage ===1){\n            if(pressedKey.key === 'ArrowUp' || pressedKey.key ==='ArrowDown'){\n                return swapUpAndDown(todoSelector,listSelector,pressedKey,todoList);\n            }\n            else if(pressedKey.key === 'ArrowRight' && nowStage+1 <=2 || pressedKey.key === 'ArrowLeft' && nowStage-1 >=0){\n                return swapRightAndLeft(todoSelector,listSelector,pressedKey,todoList)\n            }\n        }\n        else if(nowStage ===2){\n            if(pressedKey.key === 'ArrowUp' || pressedKey.key ==='ArrowDown'){\n                return swapUpAndDown(todoSelector,listSelector,pressedKey,todoList);\n            }\n            return null;\n        }\n    }\n\n    /*\n    Memo 위아래 바꾸기\n    UpDonw : 위인지 아래인지\n    targetList : 지우고자 하는 list => 0,1,2\n    currentTodoSelector : 현재 선택된 번호 => 몇번째가 선택 되었는지\n    currentMemoSelector : 현재 선택된 메모 번호\n    updateFunction : 함수에서 callback 하는 구조 => property에서 받아온 값\n    propsContents : property로 부터 받아온 [[],[],[]] 리스트 전체\n    */\n    export const swapMemoContents = (pressedKey,listSelector,todoSelector,memoSelector,todoList)=>{\n        let memoIdx = memoSelector;\n        let todoIdx = todoSelector;\n        let upDownInt = (pressedKey.key === 'ArrowUp')? -1 :1;\n        let updateContentsList = Array.from(todoList);\n        let temp = updateContentsList[listSelector][todoIdx].memolist[todoList];\n        updateContentsList[listSelector][todoIdx].memolist[memoIdx] = updateContentsList[listSelector][todoIdx].memolist[memoIdx + upDownInt];\n        updateContentsList[listSelector][todoIdx].memolist[memoIdx+upDownInt] = temp;\n        // updateFunction(updateContentsList);\n        return [listSelector,todoSelector, updateContentsList];\n    }\n\n    export const moveMemoContents = (pressedKey, listSelector, todoSelector,memoSelector,todoList)=>{\n        let upDownInt = (pressedKey.key ==='ArrowUp')? -1 : 1;\n        memoSelector = (memoSelector +1 <todoList[listSelector][todoSelector].memolist.length && memoSelector-1 >-1)?\n            memoSelector + upDownInt : memoSelector;\n        return memoSelector;\n    }\n\n\n    /*\n    MemoList 삭제\n    targetList : 지우고자 하는 list => 0,1,2\n    currentTodoSelector : 현재 선택된 번호 => 몇번째가 선택 되었는지\n    currentMemoSelector : 현재 선택된 메모 번호\n    propsContents : property로 부터 받아온 [[],[],[]] 리스트 전체\n    */\n    export const deleteMemoContents =(listSelector,todoSelector,memoSelector,todoList)=>{\n        let deleteTodoList = Array.from(todoList);\n        let memolength = deleteTodoList[listSelector][todoSelector].memolist.length;\n        for(var i = memoSelector; i<deleteTodoList[listSelector][todoSelector].length-1; i++){\n            deleteTodoList[listSelector][todoSelector].memolist[i] = \n            deleteTodoList[listSelector][todoSelector].memolist[i+1]\n        }\n        deleteTodoList[listSelector][todoSelector].memolist=\n        deleteTodoList[listSelector][todoSelector].memolist.slice(0,memolength-1);\n        return [listSelector,todoSelector, deleteTodoList];\n    }\n\n    // 함수에는 해당되는 기능만을 집중해서 구현하자 -> 함수는 필요한 것만!\n    /*\n    TodoList 삭제\n    targetList : 지우고자 하는 list => 0,1,2\n    currentTodoSelector : 현재 선택된 번호 => 몇번째가 선택 되었는지\n    propsContents : property로 부터 받아온 [[],[],[]] 리스트 전체\n    */\n    export const deleteTodoContents=(listSelector,todoSelector,todoList)=>{\n        console.log(todoList)\n        let deleteTodoList = Array.from(todoList);\n        let nextTodoSelector = (todoSelector == deleteTodoList[listSelector].length-1)? todoSelector-1 : todoSelector;\n        for(var i=todoSelector; i<deleteTodoList[listSelector].length-1; i++){\n            deleteTodoList[listSelector][i] = deleteTodoList[listSelector][i+1];\n        }\n        console.log(deleteTodoList)\n        deleteTodoList[listSelector] = deleteTodoList[listSelector].slice(0,todoList[listSelector].length-1);\n        console.log(listSelector,nextTodoSelector, deleteTodoList)\n        return [listSelector,nextTodoSelector, deleteTodoList];\n    }\n\n    \n\n\n    export const moveUpAndDown = (todoSelector,listSelector,pressedKey,todoList)=>{\n        let nextTodoSelector;\n        if(pressedKey.key === 'ArrowUp'){\n            nextTodoSelector = (todoSelector !=0) ? todoSelector-1 : todoSelector;\n        }\n        else{\n            nextTodoSelector = (todoSelector !=todoList[listSelector].length-1)? todoSelector+1 : todoSelector;\n        }\n        return [listSelector,nextTodoSelector,todoList]\n    }\n\n    \n\n    //return next TodoSelector from pressedKey\n    //return [listSelector, todoSelector]\n    export const moveTodoContents = (todoSelector,listSelector, pressedKey, nowStage, todoList)=>{\n        if(nowStage == 0){\n            if(pressedKey.key === 'ArrowUp' || pressedKey.key === 'ArrowDown'){\n                return moveUpAndDown(todoSelector,listSelector,pressedKey,todoList);\n            }\n            \n        }\n        else if(nowStage === 1){\n            if(pressedKey.key === 'ArrowUp' || pressedKey.key ==='ArrowDown'){\n                return moveUpAndDown(todoSelector,listSelector,pressedKey,todoList);\n            }else if(pressedKey.key =='ArrowRight' || pressedKey.key == 'ArrowLeft'){\n                let nextTodoSelector = 0 ; let nextListSelctor;\n                if(pressedKey.key === 'ArrowRight'){\n                    nextListSelctor = (listSelector !=2)? nextListSelctor+1 : nextListSelctor;\n                }else if(pressedKey.key === 'ArrowLeft'){\n                    nextListSelctor = (listSelector !=0)? nextListSelctor-1 : nextListSelctor;\n                }\n                return [nextListSelctor, nextTodoSelector]\n            }\n        }\n        else if(nowStage === 2){\n            if(pressedKey.key === 'ArrowUp' || pressedKey.key === 'ArrowDown'){\n                return moveUpAndDown(todoSelector,listSelector,pressedKey,todoList);\n            }\n        }\n    }","/Users/jonggeun/Desktop/anfree/anfreeFront/anfree/src/Modal.js",["123","124","125","126"],[],"import React, { useEffect, useState } from \"react\";\nimport \"./Modal.css\"\nconst Modal = (props) => {  \n    const {modalState,header,nowStage, modelClose,modelCloseAndGoNext,modelCloseAndGoNext2} = props;\n    console.log(props)\n    return (\n      // 모달이 열릴때 openModal 클래스가 생성된다.\n      <div className={ (modalState && nowStage!=2) ? 'openModal modal' : 'modal'}>\n        {modalState ? (\n          <section>\n            <header>\n              {header}\n              <button onClick= {modelClose} className=\"close\">\n                &times;\n              </button>\n            </header>\n            <main>{props.children}</main>\n            <footer>\n                <button className='prev' onClick={modelClose}>NO</button>\n                <button className='next' onClick={modelCloseAndGoNext}>YES</button>\n                {/* <button className='next' onClick={(nowStage==0)? modelCloseAndGoNext : modelCloseAndGoNext2}>YES</button> */}\n            </footer>\n          </section>\n        ) : null}\n      </div>\n    );\n  };\n\n  \n  export default Modal;",{"ruleId":"127","severity":1,"message":"128","line":50,"column":46,"nodeType":"129","messageId":"130","endLine":50,"endColumn":48},{"ruleId":"131","severity":1,"message":"132","line":55,"column":5,"nodeType":"133","endLine":55,"endColumn":21,"suggestions":"134"},{"ruleId":"127","severity":1,"message":"135","line":75,"column":29,"nodeType":"129","messageId":"130","endLine":75,"endColumn":31},{"ruleId":"136","severity":1,"message":"137","line":95,"column":9,"nodeType":"138","messageId":"139","endLine":95,"endColumn":23},{"ruleId":"140","replacedBy":"141"},{"ruleId":"142","replacedBy":"143"},{"ruleId":"144","severity":1,"message":"145","line":17,"column":15,"nodeType":"146","messageId":"130","endLine":17,"endColumn":19,"fix":"147"},{"ruleId":"148","severity":1,"message":"149","line":1,"column":37,"nodeType":"150","messageId":"151","endLine":1,"endColumn":43},{"ruleId":"148","severity":1,"message":"152","line":15,"column":10,"nodeType":"150","messageId":"151","endLine":15,"endColumn":20},{"ruleId":"131","severity":1,"message":"153","line":24,"column":25,"nodeType":"150","endLine":24,"endColumn":36},{"ruleId":"148","severity":1,"message":"154","line":1,"column":10,"nodeType":"150","messageId":"151","endLine":1,"endColumn":16},{"ruleId":"148","severity":1,"message":"155","line":2,"column":27,"nodeType":"150","messageId":"151","endLine":2,"endColumn":31},{"ruleId":"127","severity":1,"message":"128","line":31,"column":88,"nodeType":"129","messageId":"130","endLine":31,"endColumn":90},{"ruleId":"127","severity":1,"message":"128","line":33,"column":91,"nodeType":"129","messageId":"130","endLine":33,"endColumn":93},{"ruleId":"127","severity":1,"message":"128","line":37,"column":88,"nodeType":"129","messageId":"130","endLine":37,"endColumn":90},{"ruleId":"127","severity":1,"message":"128","line":39,"column":91,"nodeType":"129","messageId":"130","endLine":39,"endColumn":93},{"ruleId":"156","severity":1,"message":"157","line":97,"column":21,"nodeType":"150","messageId":"158","endLine":97,"endColumn":41},{"ruleId":"148","severity":1,"message":"154","line":1,"column":10,"nodeType":"150","messageId":"151","endLine":1,"endColumn":16},{"ruleId":"148","severity":1,"message":"155","line":2,"column":27,"nodeType":"150","messageId":"151","endLine":2,"endColumn":31},{"ruleId":"127","severity":1,"message":"128","line":128,"column":62,"nodeType":"129","messageId":"130","endLine":128,"endColumn":64},{"ruleId":"127","severity":1,"message":"128","line":156,"column":92,"nodeType":"129","messageId":"130","endLine":156,"endColumn":94},{"ruleId":"127","severity":1,"message":"128","line":158,"column":95,"nodeType":"129","messageId":"130","endLine":158,"endColumn":97},{"ruleId":"127","severity":1,"message":"128","line":162,"column":92,"nodeType":"129","messageId":"130","endLine":162,"endColumn":94},{"ruleId":"127","severity":1,"message":"128","line":164,"column":95,"nodeType":"129","messageId":"130","endLine":164,"endColumn":97},{"ruleId":"156","severity":1,"message":"157","line":188,"column":25,"nodeType":"150","messageId":"158","endLine":188,"endColumn":45},{"ruleId":"140","replacedBy":"159"},{"ruleId":"142","replacedBy":"160"},{"ruleId":"148","severity":1,"message":"155","line":1,"column":17,"nodeType":"150","messageId":"151","endLine":1,"endColumn":21},{"ruleId":"148","severity":1,"message":"161","line":1,"column":23,"nodeType":"150","messageId":"151","endLine":1,"endColumn":31},{"ruleId":"127","severity":1,"message":"128","line":35,"column":75,"nodeType":"129","messageId":"130","endLine":35,"endColumn":77},{"ruleId":"127","severity":1,"message":"128","line":43,"column":75,"nodeType":"129","messageId":"130","endLine":43,"endColumn":77},{"ruleId":"162","severity":1,"message":"163","line":12,"column":63,"nodeType":"164","messageId":"165","endLine":12,"endColumn":103},{"ruleId":"127","severity":1,"message":"128","line":24,"column":45,"nodeType":"129","messageId":"130","endLine":24,"endColumn":47},{"ruleId":"127","severity":1,"message":"128","line":26,"column":45,"nodeType":"129","messageId":"130","endLine":26,"endColumn":47},{"ruleId":"166","severity":1,"message":"167","line":57,"column":53,"nodeType":"168","messageId":"169","endLine":57,"endColumn":55},{"ruleId":"166","severity":1,"message":"167","line":57,"column":71,"nodeType":"168","messageId":"169","endLine":57,"endColumn":73},{"ruleId":"166","severity":1,"message":"170","line":57,"column":71,"nodeType":"168","messageId":"169","endLine":57,"endColumn":73},{"ruleId":"166","severity":1,"message":"170","line":57,"column":105,"nodeType":"168","messageId":"169","endLine":57,"endColumn":107},{"ruleId":"127","severity":1,"message":"135","line":127,"column":46,"nodeType":"129","messageId":"130","endLine":127,"endColumn":48},{"ruleId":"127","severity":1,"message":"128","line":143,"column":46,"nodeType":"129","messageId":"130","endLine":143,"endColumn":48},{"ruleId":"127","severity":1,"message":"128","line":146,"column":46,"nodeType":"129","messageId":"130","endLine":146,"endColumn":48},{"ruleId":"127","severity":1,"message":"135","line":156,"column":21,"nodeType":"129","messageId":"130","endLine":156,"endColumn":23},{"ruleId":"127","severity":1,"message":"135","line":165,"column":37,"nodeType":"129","messageId":"130","endLine":165,"endColumn":39},{"ruleId":"127","severity":1,"message":"135","line":165,"column":70,"nodeType":"129","messageId":"130","endLine":165,"endColumn":72},{"ruleId":"127","severity":1,"message":"128","line":168,"column":53,"nodeType":"129","messageId":"130","endLine":168,"endColumn":55},{"ruleId":"127","severity":1,"message":"128","line":170,"column":53,"nodeType":"129","messageId":"130","endLine":170,"endColumn":55},{"ruleId":"148","severity":1,"message":"171","line":1,"column":17,"nodeType":"150","messageId":"151","endLine":1,"endColumn":26},{"ruleId":"148","severity":1,"message":"161","line":1,"column":28,"nodeType":"150","messageId":"151","endLine":1,"endColumn":36},{"ruleId":"148","severity":1,"message":"172","line":4,"column":71,"nodeType":"150","messageId":"151","endLine":4,"endColumn":91},{"ruleId":"127","severity":1,"message":"128","line":8,"column":47,"nodeType":"129","messageId":"130","endLine":8,"endColumn":49},"eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'prevStage'. Either include it or remove the dependency array.","ArrayExpression",["173"],"Expected '===' and instead saw '=='.","react/jsx-pascal-case","Imported JSX component History_nav must be in PascalCase or SCREAMING_SNAKE_CASE","JSXOpeningElement","usePascalOrSnakeCase","no-native-reassign",["174"],"no-negated-in-lhs",["175"],"no-extra-bind","The function binding is unnecessary.","CallExpression",{"range":"176","text":"177"},"no-unused-vars","'useRef' is defined but never used.","Identifier","unusedVar","'stageState' is assigned a value but never used.","React Hook useCallback does nothing when called with only one argument. Did you forget to pass an array of dependencies?","'render' is defined but never used.","'memo' is defined but never used.","no-redeclare","'_pressArrowDirection' is already defined.","redeclared",["174"],["175"],"'useState' is defined but never used.","no-self-assign","'swapTodoList[listSelector][todoSelector]' is assigned to itself.","MemberExpression","selfAssignment","no-mixed-operators","Unexpected mix of '&&' and '||'. Use parentheses to clarify the intended order of operations.","LogicalExpression","unexpectedMixedOperator","Unexpected mix of '||' and '&&'. Use parentheses to clarify the intended order of operations.","'useEffect' is defined but never used.","'modelCloseAndGoNext2' is assigned a value but never used.",{"desc":"178","fix":"179"},"no-global-assign","no-unsafe-negation",[639,650],"","Update the dependencies array to be: [prevModalState, prevStage]",{"range":"180","text":"181"},[1309,1325],"[prevModalState, prevStage]"]